<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="utf-8">
    <title>Python VO cursus</title>
    <link rel="stylesheet" type="text/css" href="../style/stylesheet.css">
    <link href="https://netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css" rel="stylesheet">


<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
<div class="container">
  <img id='languagelogo' src='../img/pythonLogo.jpg'/>
  <div id='content'>



<h1 id="hoofdstuk-7---iteraties-for-loop">Hoofdstuk 7b - Iteraties: For-loop</h1>

<b>Let op:</b> log eerst in bij <a href="http://repl.it">repl.it</a><br>
<i><a href="IteratiesForAfsluitendeOpgaven.html">Meteen naar de Afsluitende Opgaven met For loop</a></i><br>
<i><a href="IteratiesGemengdeOpgaven.html">Meteen naar de Gemengde Opgaven met While en For loops</a></i><br>
<i><a href="http://course.cs.ru.nl/pythonVO/">Terug naar de cursus pagina</a></i>
<hr>

<h2 id="for-loop"><code>for</code> loop <!-- H7.2.1 --></h2>
<p>Een alternatieve manier om loops te implementeren is via de <code>for</code> loop. <code>for</code> loops zijn gemakkelijker en veiliger te gebruiken dan <code>while</code> loops, maar kunnen niet voor alle iteratie problemen gebruikt worden. <code>while</code> loops bieden een generieke oplossing voor loops. Met andere woorden, alles wat een <code>for</code> loop kan doen, kan een <code>while</code> loop ook doen, maar niet andersom.</p>
<p>De syntax voor de <code>for</code> loop is:</p>


<pre class="python">
for < variabele > in < collectie > :
        < acties >
</pre>

<p>Een <code>for</code> loop krijgt een collectie van items, en verwerkt deze items één voor één in de volgorde waarin ze worden aangeboden. Iedere cyclus door de loop verwerkt één item door het in de variabele te stoppen die naast de <code>for</code> staat. Die variabele kan dan gebruikt worden in het blok code van de loop. <!--De variabele hoeft niet te bestaan voordat de `for` loop bezocht wordt. Als de variabele al bestaat, wordt hij overschreven. Als hij nog niet bestaat, wordt hij aangemaakt. Het is overigens een echte variabele, in de zin dat hij nog steeds bestaat als de loop afgelopen is. --> Na afloop van de loop bevat hij het laatste item dat verwerkt is.</p>
<!--Op dit punt vraag je je wellicht af wat een “collectie” is. Er zijn verschillende soorten collecties in Python, en ik zal er een paar introduceren in dit hoofdstuk. In latere hoofdstukken volgen er meer.-->

<h3 id="for-loop-met-strings"><code>for</code> loop met strings</h3>
<!--De enige collectie die in de voorgaande hoofdstukken besproken is, is de string. -->
<p>Een string is een collectie van tekens, bijvoorbeeld, de string &quot;banaan&quot; is een collectie van de tekens &quot;b&quot;, &quot;a&quot;, &quot;n&quot;, &quot;a&quot;, &quot;a&quot;, en &quot;n&quot;, in die specifieke volgorde. De volgende code verwerkt ieder van de tekens van deze collectie:</p>
<pre class="python">
for letter in "banaan":
    print( letter )

print( "Klaar" )
</pre>


<!--Hoewel deze code vrij triviaal is, zal ik hem voor de duidelijkheid stap voor stap bespreken (ik heb geen stroomdiagram gemaakt, want dat is lastig voor `for` loops).-->

<p>Als de <code>for</code> loop wordt aangetroffen, neemt Python <!--de collectie (de string "banaan" in dit geval) en maakt er een zogeheten “iterabele” van.
Wat dat precies is komt pas in hoofdstuk 23 aan de orde, maar vooralsnog mag je aannemen dat het een lijst is van alle tekens in de string, in de volgorde dat ze in de string staan.
Python neemt dan -->de eerste van deze tekens, en stopt hem in de variabele <code>letter</code>. Daarna voert Python het blok code onder de <code>for</code> uit.</p>
<p>Het blok code bevat maar één regel, namelijk het printen van letter. Het programma print dus de letter “b,” en keert dan terug bij de <code>for</code>. Python neemt dan het volgende teken, namelijk de eerste “a,” en voert wederom het blok code uit, maar nu met &quot;a&quot; als waarde in <code>letter</code>. Dit proces wordt herhaald voor ieder van de tekens. Nadat alle tekens verwerkt zijn, eindigt de <code>for</code> loop. Python voert dan nog de laatste regel van het programma uit, het printen van het woord “Klaar.”</p>
<!--Om volledig helder te zijn: In de `for` loop hoef je niet ergens expliciet een variabele te verhogen of zo, of zelf iets te schrijven dat het volgende teken van de string pakt.
De `for `loop handelt dat automatisch af: iedere keer dat de loop terugkeert bij de regel met de `for`, wordt het volgende item uit de collectie gepakt.-->


<h3 id="opgave-7.2.1-teller-in-een-for-loop"><span style="color:red">Opgave</span> 7.2.1 Teller in een for-loop</h3>
<iframe frameborder="0" width="100%" height="600px" src="https://repl.it/student_embed/assignment/847616/0197719f4a72e1533d9e0630ad21ffb1"></iframe>

Deze opdracht wordt nog niet automatisch gecontroleerd. <a href="IteratiesFor_oplossingen.html#opgave-7.2.1-teller-in-een-for-loop">Klik hier</a> om je eigen oplossing te vergelijken met een model oplossing.



<h3 id="for-loop-met-een-variabele-collectie"><code>for</code> loop met een variabele collectie <!-- H 7.2.2--></h3>
<p>In de code hiervoor werd de string &quot;banaan&quot; gebruikt als collectie, maar er had ook een variabele gebruikt kunnen worden die een string bevat. Bijvoorbeeld, de volgende code is gelijk aan de vorige:</p>

<pre class="python">
fruit = "banaan"
for letter in fruit:
    print( letter )
print( "Klaar" )</pre>


<!--
Je kunt je afvragen of dat niet gevaarlijk is. Wat gebeurt er als de programmeur iets in het blok code van de loop schrijft dat de inhoud van de variabele `fruit` wijzigt? Je kunt het effect hiervan testen met de volgende code:


```python
fruit = "banaan"
for letter in fruit:
    print( letter )
    if letter == "n":
        fruit = "mango"
print( "Klaar" )
```

Als je deze code uitvoert, merk je dat het wijzigen van de inhoud van de variabele `fruit` in de loop geen effect heeft op het proces. De serie tekens die de loop verwerkt wordt slechts eenmalig bepaald, namelijk de eerste keer dat Python de loop betreedt. Het wijzigen van fruit in "mango" gedurende het proces waarbij de loop de tekens van "banaan" verwerkt, laat de loop niet ophouden met het verwerken "banaan". Het is een prachtige eigenschap van `for` loops dat ze gegarandeerd eindigen. `for` loops kunnen niet eindeloos zijn!

Wat bovenstaande code ook illustreert is dat het mogelijk is om een conditie in het blok code van een loop te stoppen. Wellicht verbaast je dat niet, en het hoeft je ook niet te verbazen, want de syntactische definitie van loops legt geen beperkingen op aan wat de acties zijn die een loop mag uitvoeren. Dus zulke acties mogen condities zijn. Het mogen zelfs loops zijn (meer daarover volgt later in dit hoofdstuk).
-->

<p>Het is ook mogelijk om een conditie in de code van een loop te stoppen.</p>
<p>Met deze code controleer je of er een '@' in een emailadres voorkomt:</p>
<pre class="python">
emailadres = "voornaam.achternaam@gmail.com"
for letter in emailadres:
    if letter == "@":
        print("Ja, een @ zit in het emailadres.")</pre>


<h3 id="opgave-7.2.2-controle-op-emailadres"><span style="color:red">Opgave</span> 7.2.2 Controle op emailadres</h3>
<iframe frameborder="0" width="100%" height="600px" src="https://repl.it/student_embed/assignment/847617/7a2bd3aa6c16d5fa1b4e855fff413488"></iframe>

Deze opdracht wordt nog niet automatisch gecontroleerd. <a href="IteratiesFor_oplossingen.html#opgave-7.2.2-controle-op-emailadres">Klik hier</a> om je eigen oplossing te vergelijken met een model oplossing.



<h3 id="for-loop-met-een-getallenreeks"><code>for</code> loop met een getallenreeks <!-- H 7.2.3.1 --></h3>
<p>Python heeft een functie <code>range()</code> die het mogelijk maakt een serie opeenvolgende getallen te genereren. <code>range()</code> wordt vaak gebruikt in combinatie met een <code>for</code> loop, bijvoorbeeld om een loop te maken die een specifiek aantal malen wordt uitgevoerd. De eenvoudigste manier om <code>range()</code> aan te roepen is met één parameter, namelijk een integer. De functie genereert dan een opeenvolgende lijst van integers, beginnend bij nul, tot aan maar niet inclusief de parameter.</p>
<p>De volgende code drukt 10 waarden af, beginnend bij 0. Dus: 0,1,2,3, ..., 9</p>
<pre class="python">
for x in range( 10 ):
    print( x )
</pre>

<h3 id="opgave-7.2.3.1-strafregels"><span style="color:red">Opgave</span> 7.2.3.1 Strafregels</h3>
<iframe frameborder="0" width="100%" height="600px" src="https://repl.it/student_embed/assignment/847618/61055fed97a8c802861f432fc67cc59b"></iframe>
Deze opdracht wordt nog niet automatisch gecontroleerd. <a href="IteratiesFor_oplossingen.html#opgave-7.2.3.1-strafregels">Klik hier</a> om je eigen oplossing te vergelijken met een model oplossing.


<h3 id="for-loop-met-meerdere-parameters"><code>for</code> loop met meerdere parameters <!-- H7.2.3.2 --></h3>
<p><code>range()</code> kan meer dan één parameter meekrijgen. Als je er twee meegeeft, dan is de eerste het startgetal (de default is nul), en de tweede het eindgetal. Het eerste getal zit in de gegenereerde serie, het tweede niet. Als je drie getallen meegeeft, zijn de eerste twee als direct hiervoor aangegeven, en is de derde een stapgrootte, dat wil zeggen, de afstand tussen de gegenereerde getallen. Default stapgrootte is 1. Als je wilt aftellen dan is dat mogelijk: je geeft dan een negatieve stapgrootte. Je moet dan wel ervoor zorgen dat het startgetal groter is dan het eindgetal.</p>
<pre class="python">
for x in range( 1, 11, 2 ):
    print( x )
</pre>
<p>In de bovenstaande code is:</p>
<ul>
<li>het startgetal is 1</li>
<li>het eindgetal is 11</li>
<li>de stapgrootte is 2</li>
</ul>
<p>De code drukt dus een aantal getallen af. Het begint bij 1, telt er steeds 2 bij op, en stopt als het getal de waarde 11 bereikt.</p>
<!--### <span style="color:red">Opgave</span>**

Wijzig in bovenstaande code de drie parameters een paar keer, om het effect van deze wijzigingen te bestuderen. Ga door totdat je de `range()` functie begrijpt.

-->

<h3 id="opgave-7.2.3.2-veelvouden-afdrukken"><span style="color:red">Opgave</span> 7.2.3.2 Veelvouden afdrukken</h3>
<iframe frameborder="0" width="100%" height="600px" src="https://repl.it/student_embed/assignment/847622/5883d45eb8c457393257e2742323623f"></iframe>

Deze opdracht wordt nog niet automatisch gecontroleerd. <a href="IteratiesFor_oplossingen.html#opgave-7.2.3.2-veelvouden-afdrukken">Klik hier</a> om je eigen oplossing te vergelijken met een model oplossing.



<h3 id="for-loop-met-een-handmatige-collectie"><code>for</code> loop met een handmatige collectie</h3>
<p>Als je een serie items hebt in een collectie die je “handmatig” hebt samengesteld, kun je die middels een <code>for</code> loop verwerken als je de items tussen haakjes zet. Een serie items tussen haakjes is een “tuple.” Tuples worden in hoofdstuk 11 uitgebreid besproken.</p>
<pre class="python">
for x in ( 10, 100, 1000, 10000 ):
    print( x )
</pre>


<h3 id="opgave-for-loop-met-een-handmatige-collectie"><span style="color:red">Opgave</span> 7.2.3.3 Collectie doorlopen met een 'for' loop</h3>

<iframe frameborder="0" width="100%" height="600px" src="https://repl.it/student_embed/assignment/847626/e2324f71ad8a2717e7fdd6287fac8bf7"></iframe>

Deze opdracht wordt nog niet automatisch gecontroleerd. <a href="IteratiesFor_oplossingen.html#opgave-for-loop-met-een-handmatige-collectie">Klik hier</a> om je eigen oplossing te vergelijken met een model oplossing.



<!--### `for` loop oefeningen

Om grip te krijgen op het gebruik van for loops, zijn hier een paar oefeningen:
-->
<div id="leerdoelen"><h2>Wat je geleerd hebt over Iteraties met een for-loop</h2></div>

<p>In dit hoofdstuk is het volgende besproken:</p>
<ul>
<li>Wat loops zijn</li>
<li><code>for</code> loops</li>
</ul>
<hr />

<!--
**Opgave ** Ik ga geen oefening geven waarin je met een `for` loop de gebruiker vraagt om getallen totdat de gebruiker nul ingeeft. Waarom niet?
-->
<hr />
<!--
## Loop controle

Er zijn drie statements die je controle geven over de wijze waarop een loop uitgevoerd wordt. Dit zijn `else`, `break`, en `continue`. Ze werken met zowel `while` als `for` loops.

### `else`

Net als bij een `if statement`, kun je aan het einde van een loop een `else` statement toevoegen. Het blok code bij de `else` wordt uitgevoerd wanneer de loop eindigt, dus wanneer de boolean voorwaarde voor de `while` loop `False` is, of bij de `for` loop wanneer het laatste item verwerkt is.

Hier is een voorbeeld van `else` bij de `while` loop:


```python
i = 0
while i < 5:
    print( i )
    i += 1
else:
    print( "De loop eindigt, i is nu", i )
print( "Klaar" )
```

Deze code is equivalent aan het onderstaande stroomdiagram. Het stroomdiagram geeft je wellicht het idee dat het niet zinvol is een `else` te gebruiken, maar het kan heel nuttig zijn in combinatie met een `break` (die ik hierna bespreek).

<img src="img/Chart5.png" alt="Voorbeeld van else in een loop" style="width:300px;"><br>
<div align="center">Figuur 7.2: Voorbeeld van else in een loop.</div>

Hier is een voorbeeld van `else` bij de `for` loop:


```python
for fruit in ( "appel", "mango", "aardbei" ):
    print( fruit )
else:
    print( "De loop eindigt, fruit is nu", fruit )
print( "Klaar" )
```

### `break`

Het `break` statement maakt het mogelijk een loop voortijdig af te breken. Als Python een `break` tegenkomt, stopt het met het verwerken van de loop, en keert niet terug bij de eerste regel van de loop. In plaats daarvan gaat de verwerking verder met de eerste regel code na de loop.

Om te zien wat het nut daarvan is, volgt hier een interessante oefening. Ik zoek een getal dat start met een 1, en als je die 1 verplaatst naar het einde van het getal, dan is het resultaat een getal dat drie keer zo groot is als het originele getal. Bijvoorbeeld, als ik het getal 1867 neem, en ik verplaats de 1 van de start naar het einde, dan krijg ik 8671. Als 8671 drie keer 1867 zou zijn, dan is dat het antwoord dat ik zoek. Maar dat is niet zo, dus 1867 is niet correct. De code om dit op te lossen is vrij kort, en geeft het laagste getal dat het probleem oplost:


```python
i = 1
while i <= 1000000:
    num1 = int( "1" + str( i ) )
    num2 = int( str( i ) + "1" )
    if num2 == 3 * num1:
        print( num2, "is drie keer", num1 )
        break
    i += 1
else:
print( "Geen antwoord gevonden" )
```

Deze code is weergegeven in het onderstaande stroomdiagram.

<img src="img/Chart6.png" alt="Voorbeeld van break in een loop" style="width:400px;"><br>
<div align="center">Figuur 7.3: Voorbeeld van break in een loop.</div>

In dit voorbeeld zie je een goed gebruik van `break`. Omdat ik geen idee heb van hoe groot het nummer is dat ik zoek, controleer ik er gewoon een heleboel. Ik laat `i` oplopen tot 1000000. Ik weet natuurlijk niet of ik het antwoord vind voordat `i` 1000000 heeft bereikt, maar ik moet ergens een grens stellen, want misschien bestaat er wel helemaal geen getal dat aan de eis voldoet, en ik wil geen eindeloze loop bouwen. Maar gedurende het testen van getallen kan ik een onverwacht een antwoord vinden, en als dat gebeurt, dan “break” ik uit de loop, want het heeft dan geen zin meer om nog meer getallen te testen.

Het punt is dat ik een maximum van 1000000 heb gekozen niet omdat ik weet dat ik een miljoen getallen moet doorzoeken. Ik heb geen idee hoe vaak ik door de loop moet. Ik weet alleen dat als ik een antwoord vind, ik klaar ben en de loop verder kan afbreken. Dat is precies de bedoeling van de `break`.

Als ik een beetje mijn best doe kan ik er best voor zorgen dat de boolean voorwaarde de vergelijking voor me doet, via iets als `while i < 1000000 and num1 != 3 * num2`. Dit wordt wat ingewikkeld, en ik moet ook `num1` en `num2` waardes geven voordat de loop start. Het is in principe altijd mogelijk om het gebruik van `break` te vermijden. Maar een `break` kan code beter leesbaar maken, zoals het doet in dit geval.

Een `break` kan niet gebruikt worden buiten een loop. `break`s zijn alleen gedefinieerd voor loops. (Ik zie vaak studenten proberen `break` statements te gebruiken in condities die niet in een loop zitten, en dan vreemd opkijken als ze een runtime error krijgen.)

Let op: als een `break` wordt uitgevoerd bij een loop die ook een `else` heeft, dan wordt de code bij de `else` niet uitgevoerd. Ik maak daarvan goed gebruik bij de code hierboven: de tekst die aangeeft dat geen antwoord gevonden is, wordt alleen afgedrukt als er niet met een `break` uit de loop wordt gesprongen.

De volgende code controleert een cijferlijst van een student. Als alle cijfers 5.5 of hoger zijn, dan is de student geslaagd. Maar als er één of meer cijfers lager dan 5.5 zijn, dan is de student gezakt. De cijferlijst wordt verwerkt door een `for` loop.


```python
for cijfer in ( 8, 7.5, 9, 6, 6, 6, 5.5, 7, 5, 8, 7, 7.5 ):
    if cijfer < 5.5:
        print( "De student zakt!" )
        break
    else:
        print( "De student slaagt!" )
```

**<span style="color:red">Opgave</span>** Voer de code hierboven uit en zie dat de student zakt. Verwijder dan de 5 van de cijferlijst en zie dat de student nu slaagt. Bestudeer de code totdat je hem snapt.

### `continue`

Als het statement `continue` in een blok code bij een loop wordt aangetroffen, wordt onmiddellijk het uitvoeren van de huidige cyclus in de loop be&euml;indigd, en wordt teruggekeerd naar de eerste regel van de loop. Voor een `while` loop betekent dat dat de boolean voorwaarde opnieuw ge&euml;valueerd wordt, en voor een `for` loop betekent het dat het volgende item van de collectie genomen en verwerkt wordt.

De volgende code drukt alle getallen tussen 1 en 100 af die niet door 2 of 3 gedeeld kunnen worden, en die niet eindigen op een 7 of 9.


```python
num = 0
while num < 100:
    num += 1
    if num%2 == 0:
        continue
    if num%3 == 0:
        continue
    if num%10 == 7:
        continue
    if num%10 == 9:
        continue
    print( num )
```

Deze code is ook weergegeven in het onderstaande stroomdiagram.

<img src="img/Chart7.png" alt="Voorbeeld van een continue in een loop" style="width:300px;"><br>
<div align="center">Figuur 7.4: Voorbeeld van een continue in een loop.</div>

Ik weet niet wat het nut van deze lijst is, maar in ieder geval helpt `continue` om de code te schrijven. In plaats van `continue` te gebruiken was het ook mogelijk geweest een grote boolean voorwaarde te schrijven die bepaalt of een getal afgedrukt moet worden, maar dat zou snel onleesbaar worden. Maar, net zoals geldt voor `break` statements, `continue` statements kunnen altijd vermeden worden als je dat echt wilt. Ze helpen echter om code begrijpbaar te houden.

Net als `break` statements, kun je `continue` statements alleen gebruiken in loops.

Wees heel, heel voorzichtig met het gebruik van `continue` in een while loop. De meeste `while` loops gebruiken een getal dat het aantal cycli door de loop inperkt. Gewoonlijk wordt een dergelijk getal verhoogd als laatste regel van het blok code bij de loop. Een `continue` statement dat wordt uitgevoerd voordat die laatste regel bereikt is, keert terug bij de boolean voorwaarde zonder dan het getal verhoogd is. Dat kan makkelijk leiden tot een eindeloze loop. Bijvoorbeeld:

    i = 0
    while i < 10:
        if i == 5:
            continue
        i += 1

is een eindeloze loop!

**<span style="color:red">Opgave</span>** Schrijf een programma dat een reeks getallen doorloopt via een for loop. Als er een nul wordt aangetroffen in de lijst getallen, dan moet het programma onmiddellijk eindigen, en alleen het woord “Klaar” afdrukken (gebruik een break om dit te implementeren). Negatieve getallen moeten overgeslagen worden (gebruik een continue om dit te implementeren; ik weet dat het ook kan met een conditie, maar ik wil dat je oefent met continue). Als er geen nul in de reeks getallen staat, moet het programma de som van alle positieve getallen afdrukken (doe dit met een else). Druk altijd “Klaar” af als het programma eindigt. Test het programma met de reeks ( 12, 4, 3, 33, -2, -5, 7, 0, 22, 4 ).


```python
for num in ( 12, 4, 3, 33, -2, -5, 7, 0, 22, 4 ):
    # Noteer hier de code

```

Met deze getallen moet het programma alleen “Klaar” afdrukken. Als je de nul verwijdert, moet het programma 85 afdrukken (en “Klaar”).

-->
<!--
---

## The loop-en-een-half

Stel dat je de gebruik om paren getallen vraagt in een loop. Voor ieder paar getallen dat de gebruiker ingeeft wil je laten zien wat hun vermenigvuldiging is. Je wilt de gebruiker het programma laten stoppen als hij een nul ingeeft, ongeacht voor welk getal. Vanwege een onbekende reden mogen de twee getallen geen delers van elkaar zijn; als ze dat wel zijn is dat een fout en wordt het programma onmiddellijk gestopt met een fout-boodschap. Tenslotte is het een eis dat de getallen in het bereik 0 tot en met 1000 liggen; als de gebruiker een getal ingeeft dat niet in dat bereik zit wordt dat echter niet beschouwd als een fout; je wilt gewoon dat de gebruiker dan een nieuw getal ingeeft. Hoe programmeer je zoiets? Hier is een eerste poging:


```python
from pcinput import getInteger

x = 3
y = 7

while (x != 0) and (y != 0) and (x%y != 0) and (y%x != 0):
    x = getInteger( "Geef nummer 1: " )
    y = getInteger( "Geef nummer 2: " )
    if (x > 1000) or (y > 1000) or (x < 0) or (y < 0):
        print( "Nummers moeten tussen 0 en 1000 zijn" )
        continue
    print( x, "keer", y, "is", x * y )

if x == 0 or y == 0:
    print( "Klaar!" )
else:
    print( "Fout: de nummers mogen geen delers zijn" )
```

**<span style="color:red">Opgave</span>** Bestudeer deze code en maak een lijstje van alles wat je er slecht aan vindt. Als je dat gedaan hebt, lees dan verder en vergelijk je bevindingen met het lijstje hieronder. Als je zaken hebt aangetroffen die slecht zijn en die niet op de lijst staan, kun je me emailen.

Er zijn veel zaken die ik slecht vind aan deze code. Hier is mijn lijst:

- Om ervoor te zorgen dat de loop op zijn minst één keer wordt uitgevoerd, moeten `x` en `y` ge&iuml;nitialiseerd worden. Waarom met 3 en 7? Dat is willekeurig, maar ik moest twee getallen nemen die geen delers van elkaar zijn. Anders zou de loop niet zijn gestart. Over het algemeen is het niet netjes om variabelen startwaardes te geven die lijken een betekenis te hebben, terwijl ze er alleen maar zijn om de variabelen te laten bestaan terwijl de waardes betekenisloos zijn. Dat wil je het liefst vermijden.
- Als je iets ingeeft dat de loop zou moeten be&euml;indigen (bijvoorbeeld nul voor `x`), dan wordt alsnog de vermenigvuldiging uitgevoerd voordat de loop eindigt. Dat was niet de bedoeling.
- Als je 0 ingeeft voor `x`, dan wordt alsnog om `y` gevraagd, hoewel het niet uitmaakt wat voor waarde voor `y`wordt ingegeven.
- De boolean voorwaarde naast de `while` is nogal complex. In deze code is hij nog wel leesbaar, maar meer eisen aan de getallen maken het behoorlijk onbegrijpelijk.
- De fout-boodschap voor de delers wordt niet gegeven bij de test waar besloten wordt het programma af te breken (dat wil zeggen, de boolean voorwaarde bij de `while`).

De oplossing voor deze zaken die door sommige programmeurs geprefereerd wordt, is om `x` en `y` te initialiseren met waardes die de gebruiker ingeeft. Dit lost de willekeurige initialisatie op, en lost ook het probleem op dat je de vermenigvuldiging uitvoert als dat niet meer hoeft. Je moet dan wel het vragen om input verplaatsen naar het einde van de loop. Als er dan een `continue` voorkomt in de loop, moet je vlak voor die `continue` ook om de inputs vragen, anders krijg je een eindeloze loop. De code wordt dan iets als:


```python
from pcinput import getInteger

x = getInteger( "Geef nummer 1: " )
y = getInteger( "Geef nummer 2: " )

while (x != 0) and (y != 0) and (x%y != 0) and (y%x != 0):
    if (x > 1000) or (y > 1000) or (x < 0) or (y < 0):
        print( "Nummers moeten tussen 0 en 1000 zijn" )
        x = getInteger( "Geef nummer 1: " )
        y = getInteger( "Geef nummer 2: " )
        continue
    print( x, "keer", y, "is", x * y )
    x = getInteger( "Geef nummer 1: " )
    y = getInteger( "Geef nummer 2: " )

if x == 0 or y == 0:
    print( "Klaar!" )
else:
    print( "Fout: de nummers mogen geen delers zijn" )
```

De code vermijdt twee van de drie genoemde problemen, maar voegt een nieuwe toe, die het mijns inziens alleen maar erger maakt. De lijst van problemen wordt:

- Het vragen van input komt nu drie keer voor in de code, in plaats van slechts één keer.
- Als je 0 ingeeft voor `x`, vraagt de code nog steeds om een waarde voor `y`.
- De boolean voorwaarde bij de `while` is nogal complex.
- De foutmelding voor de delers staat niet bij de plek waar besloten wordt de loop te verlaten.

De “truc” die je kunt gebruiken om deze problemen te verhelpen is de besturing van de loop puur te doen middels `continue`s en `break`s (een misschien soms een `exit()` als er een fout optreedt, maar in het volgende hoofdstuk wordt daar een “nettere” oplossing voor geboden). Dus je voert de loop “altijd” uit, maar je besluit om de loop te verlaten of opnieuw in te gaan als bepaalde omstandigheden optreden die je pas in de loop controleert (en niet vooraf). Om een loop “altijd” uit te voeren kun je `while True` gebruiken (dit betekent: de test die je uitvoert om te besluiten of de loop uitgevoerd moet worden,
geeft altijd `True`).


```python
from pcinput import getInteger
from sys import exit

while True:
    x = getInteger( "Geef nummer 1: " )
    if x == 0:
        break
    y = getInteger( "Geef nummer 2: " )
    if y == 0:
        break
    if (x < 0 or x > 1000) or (y < 0 or y > 1000):
        print( "Nummers moeten tussen 0 en 1000 zijn" )
        continue
    if x%y == 0 or y%x == 0:
        print( "Fout: de nummers mogen geen delers zijn" )
        exit()
    print( x, "keer", y, "is", x * y )

print( "Klaar!" )
```

Deze code lost vrijwel alle problemen op. Het vraagt slechts eenmalig om `x` en `y`. Er is geen willekeurige initialisatie van `x` en `y`. De loop stopt onmiddellijk als een nul wordt ingegeven. En de foutmelding staat meteen daar waar de fout geconstateerd wordt. Er is geen complexe boolean voorwaarde nodig met een hoop `and`s en `or`s. De code is een beetje langer dan de eerste versie, maar lengte maakt niet uit, en de code is een stuk leesbaarder.

Het enige probleem dat nog over is, is dat als de gebruiker een waarde ingeeft buiten het bereik 0 tot en met 1000 voor `x`, hij nog steeds een waarde voor `y` moet ingeven alvorens het programma zegt dat de getallen opnieuw ingegeven moeten worden. Dat kun je het beste oplossen met functies, wat besproken wordt in het volgende hoofdstuk (je kunt het eventueel nu al oplossen met een geneste loop, maar ik zou me er niet druk om maken).

Een loop als deze, die `while True` gebruikt, wordt soms een “loop-en-een-half” genoemd. Het is een heel gebruikelijke aanpak voor het schrijven van een loop waarbij je niet precies weet wanneer de loop moet eindigen.

**<span style="color:red">Opgave</span>** De gebruiker geeft een positief geheel getal. Je gebruikt daarvoor de `getInteger()` functie van `pcinput`. Deze functie staat het echter ook toe om negatieve getallen in te geven. Als de gebruiker een negatief getal ingeeft, wil je melden dat dat niet mag, en hem opnieuw een getal laten ingeven. Dit blijf je doen totdat daadwerkelijk een positief getal is ingegeven. Zodra een positief getal is ingegeven, druk je dat af en stopt het programma. Een dergelijk probleem wordt typisch aangepakt met een loop-en-een-half, omdat je geen idee hebt van hoe vaak een gebruiker een negatief getal ingeeft totdat hij wijs wordt. Schrijf zo’n loop-en-een-half. Je heb precies één break nodig, en hoogstens één continue. Druk het positieve getal dat de gebruiker heeft ingegeven af na de loop. De reden om het erna te doen is dat de loop alleen bedoeld is om de input onder controle te krijgen, en niet voor het verwerken van de correcte invoer.


```python
# Invoer geven.

```

Ik heb vaak geconstateerd dat studenten het gebruik van `while True` maar verwarrend vinden. Ze zien het vaak in voorbeeldcode, maar ze snappen niet echt het nut ervan. En vervolgens gaan ze `while True` opnemen in code van henzelf als ze niet precies weten wat ze moeten doen. Als je problemen hebt de loop-en-een-half te begrijpen, bestudeer
dan deze paragraaf opnieuw, totdat je het wel begrijpt.

---
-->

<!--
<h2 id="slim-gebruik-van-loops">Slim gebruik van loops</h2>
<p>Ter afronding van dit hoofdstuk, bediscussieer ik een aantal strategieën voor het ontwerpen van loops, en het ontwerpen van algoritmes in het algemeen.</p>
<h3 id="wanneer-gebruik-je-een-loop">Wanneer gebruik je een loop?</h3>
<p>Als je vijf zes-zijdige dobbelstenen rolt, hoe groot is dan de waarschijnlijkheid dat je vijf zessen rolt? Het antwoord is 1 / ( 6**5 ), maar stel dat je dat niet weet, en je wilt een simulatie gebruiken om de waarschijnlijkheid te schatten. Je kunt het rollen van een dobbelstenen imiteren via <code>randint()</code>, dus daarmee kun je ook het rollen van vijf dobbelstenen imiteren. Je kunt testen of ze alle zes zijn. Dat kun je een heleboel keren doen, en aan het eind van je programma deel je het aantal keren dat er vijf zessen vielen door het totaal aantal pogingen. Als ik dit probleem voorleg aan studenten (in een iets ingewikkeldere vorm zodat het antwoord niet gemakkelijk berekend kan worden), dan krijg ik vaak code die er als volgt uitziet (je moet <code>TESTS</code> een grotere waarde geven voor een betere schatting, maar ik wilde dat deze code niet teveel tijd vergt om uit te voeren):</p>
<pre class="python"><code class="python"><span class="ch">from</span> random <span class="ch">import</span> randint

TESTS = <span class="dv">10000</span>
succes = <span class="dv">0</span>
<span class="kw">for</span> i in <span class="dt">range</span>( TESTS ):
    d1 = randint( <span class="dv">1</span>, <span class="dv">6</span> )
    d2 = randint( <span class="dv">1</span>, <span class="dv">6</span> )
    d3 = randint( <span class="dv">1</span>, <span class="dv">6</span> )
    d4 = randint( <span class="dv">1</span>, <span class="dv">6</span> )
    d5 = randint( <span class="dv">1</span>, <span class="dv">6</span> )
    <span class="kw">if</span> d1 == <span class="dv">6</span> and d2 == <span class="dv">6</span> and d3 == <span class="dv">6</span> and d4 == <span class="dv">6</span> and d5 == <span class="dv">6</span>:
        succes += <span class="dv">1</span>
<span class="dt">print</span>( <span class="st">&quot;Waarschijnlijkheid van vijf zessen is&quot;</span>, succes / TESTS )</code></pre>
<p>Als ik dit soort code zie, vraag ik: “Wat had je gedaan als ik gevraagd had 100 dobbelstenen te rollen? Had je 100 variabelen gemaakt en die regel code die ze rolt 100 keer gekopieerd?” Als je een stukje code hebt dat een paar keer herhaald wordt met slechts een kleine wijziging erin (of wanneer je aan het kopiëren en plakken bent in je eigen code), dan moet je beginnen te denken aan loops. Je kunt vijf dobbelstenen als volgt rollen:</p>
<pre class="python"><code class="python"><span class="ch">from</span> random <span class="ch">import</span> randint

<span class="kw">for</span> i in <span class="dt">range</span>( <span class="dv">5</span> ):
    d = randint( <span class="dv">1</span>, <span class="dv">6</span> )</code></pre>
<p>“Maar,” hoor ik sommigen al protesteren: “ik moet de waarde van al die vijf dobbelstenen hebben om te testen of het vijf zessen zijn! Iedere keer dat deze code door de loop gaat, gooi je de vorige dobbelsteen waarde weg!” Dat is waar, maar de regel die test of ze allemaal een zes zijn is ook erg lelijk. Kan dit geheel niet gestroomlijnd worden? Kun je geen conclusie trekken als je één dobbelsteen rolt?</p>
<p>Als je hier een beetje over nadenkt, kom je wellicht op het volgende idee: zodra je een dobbelsteen rolt die géén zes is, heb je al gefaald in je poging om vijf zessen te rollen, en kun je gelijk doorgaan met de volgende poging. Er zijn diverse manieren om dit te implementeren, maar hier is een hele korte die gebruik maakt van een <code>break</code> en een <code>else</code>:</p>
<pre class="python"><code class="python"><span class="ch">from</span> random <span class="ch">import</span> randint

TESTS = <span class="dv">10000</span>
succes = <span class="dv">0</span>
<span class="kw">for</span> i in <span class="dt">range</span>( TESTS ):
    <span class="kw">for</span> j in <span class="dt">range</span>( <span class="dv">5</span> ):
        <span class="kw">if</span> randint( <span class="dv">1</span>, <span class="dv">6</span> ) != <span class="dv">6</span>:
            <span class="kw">break</span>
    <span class="kw">else</span>:
        succes += <span class="dv">1</span>
<span class="dt">print</span>( <span class="st">&quot;Waarschijnlijkheid van vijf zessen is&quot;</span>, succes / TESTS )</code></pre>
<p>Je denkt wellicht dat het moeilijk is om zoiets te verzinnen, maar het is echt niet de enige manier. Je kunt, bijvoorbeeld, de waardes van de dobbelstenen in de loop optellen en dan testen of het totaal 30 is na de loop. Of je kunt tellen hoeveel dobbelstenen een zes zijn en dan testen of dat vijf is na de loop. Of je kunt voor de loop een boolean variabele op <code>True</code> zetten, en die in de loop op <code>False</code> zetten zodra een dobbelsteen niet op zes valt; dan kun je die boolean testen na de loop.</p>
<p>Het punt is dat een willekeurig lange herhaling van stukken code vrijwel altijd vervangen kan worden door een loop.</p>
<h3 id="data-items-één-voor-één-verwerken">Data items één voor één verwerken</h3>
<p>Het is gebruikelijk dat loops een serie data items verwerken. Iedere cyclus door de loop verwerkt dan één van die items. Vaak moet je iets onthouden over de items die je verwerkt hebt, en daarvoor heb je extra variabelen nodig. Je moet slim nadenken over welke variabelen je nodig hebt.</p>
<p>Neem het volgende voorbeeld: ik geef je tien getallen en vraag je een programma te schrijven dat bepaalt welke de grootste is, welke de kleinste, en hoeveel er deelbaar zijn door 3. Je kunt dan zeggen: “Het is gemakkelijk te bepalen wat de grootste en de kleinste zijn: daar gebruik ik gewoon de <code>max()</code> en <code>min()</code> functies voor (besproken in hoofdstuk 5). Deelbaar door 3 is misschien wat moeilijker, daar moet ik over denken.” Maar <code>max()</code> en <code>min()</code> maken het noodzakelijk dat alle tien de getallen tegelijkertijd in het geheugen worden gehouden. Dat is nog te doen voor tien getallen, maar wat als ik om honderd had gevraagd? Of een miljoen?</p>
<p>Omdat je een serie getallen moet verwerken, moet je denken over een loop, en specifiek over een loop waarin iedere cyclus door de loop één van die getallen beschikbaar is (maar waarbij ze allemaal voorbij zullen komen voordat de loop eindigt). Je moet nu denken over variabelen waarmee je iets kunt onthouden in de loop, die ervoor zorgen dat je aan het einde van de loop kunt bepalen welke de grootste was, welke de kleinste, en hoeveel deelbaar zijn door 3. Welke variabelen heb je nodig?</p>
<p>Het antwoord, dat gemakkelijk te verzinnen is voor iemand die wat ervaring heeft met programmeren, is dat je <em>tot nu toe</em>, welk het kleinste is <em>tot nu toe</em>, en hoeveel er deelbaar zijn door 3 <em>tot nu toe</em>. Dat betekent dat iedere keer dat je door de loop gaat het nieuw aangeboden getal vergelijkt met de variabelen die de grootste en de kleinste bijhouden, en je de inhoud van de variabelen vervangt als dat nodig is. Je test ook of het nieuw aangeboden getal deelbaar is door 3, en zo ja, dan verhoog je de variabele die bijhoudt hoeveel er deelbaar zijn door 3 met 1.</p>
<p>Je moet goede initiële waardes bepalen voor de drie variabelen. De variabele die deelbaarheid-door-3 bijhoudt is eenvoudig; die begint op nul. Het is wat lastiger voor de grootste en kleinste variabelen. Een goede oplossing is ze te vullen met het eerste getal, want op dat moment is dat eerste getal zowel de grootste als de kleinste.</p>
-->
<!--Dit probleem staat hieronder als een genummerde opgave. Gebruik het beschreven algoritme om de opgave op te lossen.-->



<!--
<h3 id="opgave-7.6.2-kleinste-en-aantal-getallen-in-een-reeks"><span style="color:red">Opgave</span> 7.6.2 Kleinste en aantal getallen in een reeks</h3>
<p>Schrijf een programma dat van een reeks van getallen de kleinste afdrukt en hoeveel getallen er in de reeks zitten.</p>
<p>Gebruik deze reeks: <code>( 12, -2, -5, 7, 0, 22, 4 )</code>. Voor het doorlopen van de reeks gebruik je het algoritme dat eerder in dit hoofdstuk beschreven is bij Theorie 7.2.4: &quot;for loop met een handmatige collectie&quot;.</p>
-->
<!--

```python
# Kleinste en aantal

aantal_getallen = 0
kleinste = 0
for getal in ( 12, -2, -5, 7, 0, 22, 4 ):
    aantal_getallen += 1
    if getal < kleinste:
        kleinste = getal

print( "Aantal getallen is", aantal_getallen )
print( "Kleinste is", kleinste )


```
-->





<!--

<h3 id="begin-met-de-kleinste-en-bouw-naar-buiten-op">Begin met de kleinste en bouw naar buiten op</h3>
<p>Stel dat ik je de volgende opdracht geef: Van alle boeken op alle planken in de bibliotheek moet je het aantal woorden tellen, en tenslotte moet je het gemiddelde aantal woorden per boek rapporteren. Als je dit aan een mens vraagt, zal hij of zij waarschijnlijk denken: “Ik ga naar de bibliotheek, neem het eerste boek van de eerste plank, tel de woorden en schrijf het totaal op, dan neem ik het tweede boek en doe hetzelfde, etcetera. Als ik klaar ben met de eerste plank, doe ik hetzelfde met de tweede, totdat alle boeken op alle planken gedaan heb. Dan tel ik alle totalen op, en deel dat door het aantal boeken.” Voor mensen werkt dit, maar als ik dit aan een computer wil vertellen, is dat best lastig.</p>
<p>Om dit probleem op te lossen, moet ik beginnen met de kleinste eenheid van verwerking. In dit geval is de kleinste eenheid een “boek.” Het is niet “woord,” want ik hoef niks te doen met woorden; ik moet totalen woorden per boek hebben. In pseudo-code wordt het tellen van woorden per boek iets als:</p>
<pre><code>woordtotaal = 0
for woord in boek:
    woordtotaal += 1</code></pre>
<p>Als ik zoiets codeer, kan ik het al testen. Als ik tevreden ben dat ik woorden per boek kan tellen, kan ik naar een iets grotere eenheid gaan, en dat is de “plank.” Hoe verwerk ik alle boeken op een plank? In pseudo-code is dat iets als:</p>
<pre><code>for boek on plank:
    verwerk_boek()</code></pre>
<p>Wat doet <code>verwerk_boek()</code>? Het telt de woorden. Ik heb al pseudo-code geschreven om woorden te tellen, en die kan ik hier invoegen. Dat wordt dan:</p>
<pre><code>for boek in plank:
    woordtotaal = 0
    for woord in boek:
        woordtotaal += 1</code></pre>
<p>Als ik dit test, loop ik tegen een probleem aan. Ik tel weliswaar woorden per boek, maar ik doe niks met die totalen. Ik overschrijf die gewoon. Om straks het gemiddelde te kunnen bepalen, moet ik het totaal van het aantal woorden weten over alle boeken. Dat betekent dat ik <code>woordtotaal</code> slechts één keer moet initialiseren, namelijk aan het begin.</p>
<pre><code>woordtotaal = 0
for boek in plank:
    for woord in boek
        woordtotaal += 1</code></pre>
<p>Maar om het gemiddelde te kunnen uitrekenen, moet ik ook weten hoeveel boeken ik verwerkt heb. Dat kan ik doen met een teller <code>boektotaal</code>, die ook slechts eenmalig geïnitialiseerd moet worden. Aan het einde kan ik dan het gemiddelde afdrukken.</p>
<pre><code>woordtotaal = 0
boektotaal = 0
for boek in plank:
    for woord in boek:
        woordtotaal += 1
    boektotaal += 1
print( woordtotaal / boektotaal )</code></pre>
<p>Nu kan ik naar het hoogste niveau gaan: de bibliotheek als geheel. Ik weet hoe ik één plank moet verwerken, en nu moet ik alle planken verwerken. Natuurlijk moet de initialisatie van de totalen alleen aan het begin gedaan worden, en het afdrukken van het gemiddelde alleen aan het einde. Dat wil zeggen dat ik slechts één regel hoef toe te voegen om de pseudo-code af te maken:</p>
<pre><code>woordtotaal = 0
boektotaal = 0
for plank in bibliotheek:
    for boek in plank:
        for woord in boek:
            woordtotaal += 1
        boektotaal += 1
print( woordtotaal / boektotaal )</code></pre>
<p>Zoals je ziet heb ik een drievoudig-geneste loop ontworpen, werkend van binnen naar buiten. Dit is een goede aanpak als je met geneste loops aan de slag moet.</p>


<hr />
<h2 id="over-het-ontwerpen-van-algoritmes">Over het ontwerpen van algoritmes</h2>
<p>Als je tot op dit punt van het boek gestaag hebt doorgewerkt, kom je vanaf nu opgaves en problemen tegen waarbij je niet zeker bent over hoe je ze op moet lossen. Ik gaf een voorbeeld van een dergelijk probleem hierboven (het vinden van de grootste, de kleinste, en het aantal deelbaar door 3 van tien getallen), en de oplossing die ik bedacht. Een dergelijke oplossing wordt een algoritme genoemd. Maar hoe ontwerp je zo een algoritme?</p>
<p>Ik zie vaak dat studenten code aan het typen zijn zonder dat ze weten wat ze doen of wat ze willen doen. Ze proberen een opgave op te lossen maar weten niet hoe, en dus gaan ze maar typen. Je zult je wel realiseren dat dat geen effectieve manier is om oplossingen te maken (hoewel er op zich niks is tegen een beetje experimenteren).</p>
<p>Wat je in dat soort situaties moet doen is een stapje terugzetten, het toetsenbord met rust laten, en denken: “Hoe zou ik dit als mens aanpakken?” Probeer op te schrijven wat je zou doen als je het probleem met de hand zou aanpakken. Het maakt niet uit of het een saaie taak is die je nooit met de hand zou willen doen – je hebt een computer om saaie dingen voor je te doen.</p>
<p>Als je bedacht hebt wat je zou willen doen, bedenk dat hoe je dat in code kunt opschrijven. Want in principe is dat wat je de computer moet vertellen: de stappen die een mens zou kunnen nemen om de oplossing te bereiken. Als je geen manier kunt vinden waarmee een mens het probleem zou oplossen, dan zul je zeker niet in staat zijn een computer te vertellen hoe het probleem opgelost moet worden.</p>
<hr />
-->

<hr>
<i><a href="IteratiesForAfsluitendeOpgaven.html">Verder naar de Afsluitende Opgaven over For loops</a></i><br>
<i><a href="IteratiesGemengdeOpgaven.html">Meteen naar de Gemengde Opgaven met While en For loops</a></i><br>
<i><a href="http://course.cs.ru.nl/pythonVO/">Terug naar de cursus pagina</a></i>
