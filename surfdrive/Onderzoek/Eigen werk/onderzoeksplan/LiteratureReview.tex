\section{Literature Review}\label{sec:LitReview}

\subsection{Sources of programming difficulties}

Sources of programming difficulties (or 'misconceptions') which novice
programmers encounter have been extensively researched and documented. In
their meta-analysis Sheard et al. \cite{Sheard2009} investigated 164 relevant
full refereed papers about programming education. Rountree gives a general
account of misconceptions \cite{Rountree2003}. Others focus on specific
concepts such as variables \cite{Kuittinen2004}, loops \cite{Dancik2003},
boolean conditions and control structures \cite{Almstrum1999, Herman2010}.

Spohrer and Soloway analyze difficulties related to these \emph{plan
composition} problems, and argue that these have even more impact on
programming errors than construct-based misconceptions
\cite{spohrer1986novice}.



\subsection{Problem solving difficulties}
%\subsubsection{Problem Solving heuristics}
Computer science learners often experience difficulties during problem
analysis, planning and design of solutions\cite{Hazzan2011}. Kirschner,
Sweller and Clark argue that learning a complex task like programming, not
only requires conceptual knowledge, but also \emph{explicit procedural
guidance}. It is essential to understand which steps must be taken in order
to solve a problem, as well as how to recognize an acceptable solution
\cite{kirschner2006minimal}.


McCracken et al. (2001) define 5 iterative steps to problem solving in their
research. These steps are a slight (almost textual) modification to Polya's
steps to solving a mathematical problem \cite{Polya1945}. The five steps,
are:
    \begin{enumerate}
    \item Abstract the problem from its description - Identify the relevant
        aspects from the problem description, then model the elements in an
        abstract framework.

    \item Generate sub-problems - Decomposing the design. In an
        object-oriented solution this step would pertain to determining the
        methods and submethods of a class.

    \item Transform sub-problems into sub-solutions - In this steps
        students determine an implementation strategy for individual
        classes, methods, and appropriate language constructs as well as
        data structures and programming techniques.

    \item Re-compose the sub-solutions into a working program - Combining
        the sub-solutions from the previous step into a working program /
        complete solution. This step probably involves creating an
        algorithm that controls the sequence of events.

    \item Evaluate and iterate - Determine if the previous steps have lead
        to a good solution to the problem and take appropriate action if
        not.


    \end{enumerate}



In McCracken et al. (2001) study shows that problems in programming
assignments arise when students skip steps or execute them incorrectly
\cite{McCracken2001}.



\subsubsection{Thinking first}

Kirschner, Sweller and Clark argue that learning a complex task like
programming, not only requires conceptual knowledge, but also \emph{explicit
procedural guidance}. Students spend little time thinking about how to tackle
a problem. Analysis, decomposition and solution design precede coding
\cite{natasja2014}.



Unplugged activities can be used to introduce new topics, analyze problems
and brainstorm about solutions, away from the distracting computer. Students
use the skill of decomposition more successfully in situations where they
understand the problem very well \cite{selby2015}. Using an unplugged
approach and visualizing the solution prior to implementation assures that
all students have made a start and are 'on-board', increasing growth-mindset
\cite{Cutts2010} and the necessary self-efficacy to tackle the problem at
hand. Building on both Vygotsky (1978) and Mead (1934), socioconstructivists
have shown how discussion and reflection on a specific task can help
construct an understanding that goes beyond what students can achieve on
their own.




\subsubsection{Standard \emph{plans}}

Students need a strategy to turn a conceptual design into a program
\cite{robins2003learning}\cite{spohrer1986novice}. Becoming a competent
programmer involves, among other things, establishing a collection of problem
patterns together with their standard solutions\cite{robins2003learning}.
Choosing and applying such solutions (or \emph{plans}) leads to pieces of
program that must be integrated together in the correct manner. In his
research de Raadt \cite{deRaadt2007}\cite{deRaadt2008} describes how the
explicit teaching of programming strategies improves student learning
outcomes \cite{deRaadt2006}, showing both an increase in the use of
strategies and a significant improvement in the completeness of solutions.


Plans are frequently used strategies (by experts) to accomplish a task.
Examples are traversing a list by using a for-each loop or using a counter
controlled loop to repeat tasks a certain number of iterations. To solve
complex problems, plans need to be combined sequentially, conditionally or
iteratively.


\subsubsection{The big picture}

As the  number of errors is proportional to the complexity of the problem
\cite{spohrer1986novice}, decomposition is also the key to beating
cognitive-load issues. Considering the taxonomy of educational objectives,
decomposition is a prerequisite for abstraction, algorithm design, and
evaluation\cite{selby2015}. Although they understand the concept of breaking
a problem down, learners struggle with implementing the process of
decomposition (McCracken's step 2 and 3): it is perceived to be the most
difficult programming skill to master \cite{selby2015}.

Successful \textbf{plan composition} (McCracken's step 4) is strongly
dependent on algorithmic thinking. Firstly, the correct plans must be
selected \cite{deRaadt2008} to use as a basis for the solution. Secondly, the
correct sequencing of plans must be made. Spohrer and Soloway
\cite{Soloway1982} conclude from an analysis of 101 bugs that the majority
arise from problems with abutment and merging of plans
\cite{spohrer1986novice}. Novice programmers spend little time planning
\cite{robins2003learning}.  As a result, when writing code, students dive
straight into details and seem to lose sight of the big picture
\cite{Chetty2015towards}. In McCracken et al. (2001) conclude a lack of
structure in tackling a programming problems\cite{McCracken2001}.




Flowcharts enable the visualization, communication and evaluation of proposed
solutions at an early stage, comparable to how in industry (UML) designs are
used as a high-level description to communicate with stakeholders. Similarly,
students could benefit from some kind of guidance through the process of
design, implementation and evaluation.




\subsubsection{Feedback and evaluation}

Success-experience and (concrete, specific and timely) feedback are essential
factors for motivating students to exert their utmost to understand something
and to learn \cite{Ebbens}. Novice students prefer a visual algorithm
development environment to a textual programming language
\cite{Carlisle2005}. In addition, students that are actively participating in
exploring ideas and more engaged (constructivism approach) leading to an
increased learning potential \cite{Ebbens}.

An incomplete or incorrect mental model makes it difficult for students to
envision and comprehend the behavior of programs \cite{sorva2013notional},
\cite{Chetty2015towards}. Inspired by Papert's Mindstorms philosophy (Papert,
1980), visualisation tools (such as Scratch, Logo and Mindstorms) have been
developed to allow students analyze the effects of language constructs and
algorithms, in addition to increasing motivation \cite{Chetty2015towards}.


[KOLLING en SCRATCH ONDERZOEK]. The focus on problem solving is one of the
biggest differences between the educational material used in this research,
and the official ''Introduction to Programming with Greenfoot'' by Michael
K\"olling.

The visualization capabilities of Greenfoot unquestionably have the potential
to aid understanding and concretizing abstract concepts of computing science,
particularly for novices \cite{Hazzan2011} \cite{Sheard2009}. By linking
algorithmic thinking to an implementation (programming), pupils obtain direct
visual feedback on their algorithms.

The high-level concepts of logical thinking and design are the most difficult
for students, yet receives the least feedback whilst syntax is perceived as
less difficult but receives large amounts of feedback
\cite{ButlerMorgan2007}. Being able to communicate an idea at an early stage
allows for scaffolding as students discuss the task, monitor what they learn
as they communicate their ideas, resolve conflicts, build on each otherâ€™s
ideas, and correct mistakes (Goos, Galbraith, and Renshaw, 2002; Hmelo-Silver
and Barrows, 2008).
